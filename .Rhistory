return(c(0, 0, 0))
} else {
breakpoint <- seg_fit$psi
return(breakpoint)
}
}
cycle_genotypes <-
function(infile, response, subset) {
# This function ..
#
# infile: subpath of input file
# response: string or vector of strings indicating traits on which to perform
# breakpoint analysis
for (resp in response) {
for (i in 1:3) {
df <-
read.csv(infile, header = T)
df_one_geno <- df[(df$geno == i), ]
if (i > 1) {
breakpoints <-
rbind(breakpoints, get_breakpoints(df_one_geno, resp))
print(breakpoints)
} else {
breakpoints <- get_breakpoints(df_one_geno, resp)
print(breakpoints)
}
}
breakpoints <- as.data.frame(breakpoints)
colnames(breakpoints) <- c("Initial", "Est.", "St.Err") # Needed in case a 3x3 matrix of zeros with no colnames is made!
breakpoints$geno <- c(11, 2, 5)
breakpoints$measure <- c(rep(resp, 3))
breakpoints$subset <- c(rep(subset, 3))
if (resp != response[1]) {
breakpoints_df <- rbind(breakpoints_df, breakpoints)
} else {
breakpoints_df <- breakpoints
}
}
rownames(breakpoints_df) <- seq(1, nrow(breakpoints_df))
return(breakpoints_df)
}
run_breakpoint_analysis <-
function() {
df <-
rbind(
cycle_genotypes(
infile = "data/recovery_plants_clean.csv",
subset = "Recovery",
response =  c(
"urgr",
"uH",
"max_rgr",
"max_H",
"B_total",
"B_below",
"B_above",
"A_B"
)
),
cycle_genotypes(
infile = "data/biomass_plants_clean.csv",
subset = "Cumulative",
response =  c(
"ssa",
"srl",
"SLA",
"Rv",
"Rt",
"Rsa_la",
"Rsa",
"Rl",
"Rd",
"LA",
"DMCv",
"DMCr",
"Bv",
"Br",
"A_B"
)
),
cycle_genotypes(
infile = "data/phys_plants_clean.csv",
subset = "Instantaneous",
response =  c(
"uWUEi",
"ugs",
"ufv",
"uAnet",
"max_WUEi",
"max_gs",
"max_fv",
"max_Anet"
)
),
cycle_genotypes(
infile = "data/all_plants_clean.csv",
subset = "Growth",
response =  c(
"urgr",
"uH",
"max_rgr",
"max_H")
)
)
write.csv(df, file = "output/breakpoint_analysis.csv")
}
cycle_genotypes(
infile = "data/all_plants_clean.csv",
subset = "Growth",
response =  c(
"urgr",
"uH",
"max_rgr",
"max_H")
)
response = "urgr"
subset = "Growth"
infile = "data/all_plants_clean.csv"
for (resp in response) {
for (i in 1:3) {
df <-
read.csv(infile, header = T)
df_one_geno <- df[(df$geno == i), ]
if (i > 1) {
breakpoints <-
rbind(breakpoints, get_breakpoints(df_one_geno, resp))
print(breakpoints)
} else {
breakpoints <- get_breakpoints(df_one_geno, resp)
print(breakpoints)
}
}
for (resp in response) {
for (i in 1:3) {
df <-
read.csv(infile, header = T)
df_one_geno <- df[(df$geno == i), ]
if (i > 1) {
breakpoints <-
rbind(breakpoints, get_breakpoints(df_one_geno, resp))
print(breakpoints)
} else {
breakpoints <- get_breakpoints(df_one_geno, resp)
print(breakpoints)
}
}
breakpoints <- as.data.frame(breakpoints)
colnames(breakpoints) <- c("Initial", "Est.", "St.Err") # Needed in case a 3x3 matrix of zeros with no colnames is made!
breakpoints$geno <- c(11, 2, 5)
breakpoints$measure <- c(rep(resp, 3))
breakpoints$subset <- c(rep(subset, 3))
if (resp != response[1]) {
breakpoints_df <- rbind(breakpoints_df, breakpoints)
} else {
breakpoints_df <- breakpoints
}
}
response[1]
resp
breakpoints
?segmented
###########################################################################################
## DETERMINE BREAKPOINTS IN GENOTYPE TREATMENT FUNCTION
###########################################################################################
# Very nice information about segmented here: https://rpubs.com/MarkusLoew/12164
get_breakpoints <-
function(df, response) {
fit <-
lm(as.formula(paste(response, " ~ trt", sep = "")), data = df)
seg_fit <- suppressWarnings(segmented::segmented(fit,
seg.Z = ~ trt,
n.psi = 1)) # Only one breakpoint, for simplicity
if (is.null(seg_fit$psi)) {
return(c(0, 0, 0))
} else {
breakpoint <- seg_fit$psi
return(breakpoint)
}
}
cycle_genotypes <-
function(infile, response, subset) {
# This function ..
#
# infile: subpath of input file
# response: string or vector of strings indicating traits on which to perform
# breakpoint analysis
for (resp in response) {
for (i in 1:3) {
df <-
read.csv(infile, header = T)
df_one_geno <- df[(df$geno == i), ]
if (i > 1) {
breakpoints <-
rbind(breakpoints, get_breakpoints(df_one_geno, resp))
print(breakpoints)
} else {
breakpoints <- get_breakpoints(df_one_geno, resp)
print(breakpoints)
}
}
breakpoints <- as.data.frame(breakpoints)
colnames(breakpoints) <- c("Initial", "Est.", "St.Err") # Needed in case a 3x3 matrix of zeros with no colnames is made!
breakpoints$geno <- c(11, 2, 5)
breakpoints$measure <- c(rep(resp, 3))
breakpoints$subset <- c(rep(subset, 3))
if (resp != response[1]) {
breakpoints_df <- rbind(breakpoints_df, breakpoints)
} else {
breakpoints_df <- breakpoints
}
}
rownames(breakpoints_df) <- seq(1, nrow(breakpoints_df))
return(breakpoints_df)
}
run_breakpoint_analysis <-
function() {
df <-
rbind(
cycle_genotypes(
infile = "data/recovery_plants_clean.csv",
subset = "Recovery",
response =  c(
"urgr",
"uH",
"max_rgr",
"max_H",
"B_total",
"B_below",
"B_above",
"A_B"
)
),
cycle_genotypes(
infile = "data/biomass_plants_clean.csv",
subset = "Cumulative",
response =  c(
"ssa",
"srl",
"SLA",
"Rv",
"Rt",
"Rsa_la",
"Rsa",
"Rl",
"Rd",
"LA",
"DMCv",
"DMCr",
"Bv",
"Br",
"A_B"
)
),
cycle_genotypes(
infile = "data/phys_plants_clean.csv",
subset = "Instantaneous",
response =  c(
"uWUEi",
"ugs",
"ufv",
"uAnet",
"max_WUEi",
"max_gs",
"max_fv",
"max_Anet"
)
),
cycle_genotypes(
infile = "data/all_plants_clean.csv",
subset = "Growth",
response =  c(
"urgr",
"uH",
"max_rgr",
"max_H")
)
)
write.csv(df, file = "output/breakpoint_analysis.csv")
}
# breakpoint analysis
for (resp in response) {
for (i in 1:3) {
df <-
read.csv(infile, header = T)
df_one_geno <- df[(df$geno == i), ]
if (i > 1) {
breakpoints <-
rbind(breakpoints, get_breakpoints(df_one_geno, resp))
print(breakpoints)
} else {
breakpoints <- get_breakpoints(df_one_geno, resp)
print(breakpoints)
}
}
breakpoints <- as.data.frame(breakpoints)
colnames(breakpoints) <- c("Initial", "Est.", "St.Err") # Needed in case a 3x3 matrix of zeros with no colnames is made!
breakpoints$geno <- c(11, 2, 5)
breakpoints$measure <- c(rep(resp, 3))
breakpoints$subset <- c(rep(subset, 3))
if (resp != response[1]) {
breakpoints_df <- rbind(breakpoints_df, breakpoints)
} else {
breakpoints_df <- breakpoints
}
}
get_breakpoints <-
function(df, response) {
fit <-
lm(as.formula(paste(response, " ~ trt", sep = "")), data = df)
seg_fit <- suppressWarnings(segmented::segmented(fit,
seg.Z = ~ trt,
n.psi = 1)) # Only one breakpoint, for simplicity
if (is.null(seg_fit$psi)) {
return(c(0, 0, 0))
} else {
breakpoint <- seg_fit$psi
return(breakpoint)
}
}
i = 1
df <-
read.csv(infile, header = T)
df_one_geno <- df[(df$geno == i), ]
get_breakpoints(df_one_geno, resp)
i = 2
df <-
read.csv(infile, header = T)
df_one_geno <- df[(df$geno == i), ]
get_breakpoints(df_one_geno, resp)
i = 3
df_one_geno <- df[(df$geno == i), ]
get_breakpoints(df_one_geno, resp)
df_one_geno
###########################################################################################
## DETERMINE BREAKPOINTS IN GENOTYPE TREATMENT FUNCTION
###########################################################################################
# Very nice information about segmented here: https://rpubs.com/MarkusLoew/12164
get_breakpoints <-
function(df, response) {
fit <-
lm(as.formula(paste(response, " ~ trt", sep = "")), data = df)
seg_fit <- suppressWarnings(segmented::segmented(fit,
seg.Z = ~ trt,
n.psi = 1)) # Only one breakpoint, for simplicity
if (is.null(seg_fit$psi)) {
return(c(0, 0, 0))
} else {
breakpoint <- seg_fit$psi
return(breakpoint)
}
}
cycle_genotypes <-
function(infile, response, subset) {
# This function ..
#
# infile: subpath of input file
# response: string or vector of strings indicating traits on which to perform
# breakpoint analysis
for (resp in response) {
for (i in 1:3) {
df <-
read.csv(infile, header = T)
df_one_geno <- df[(df$geno == i), ]
if (i > 1) {
breakpoints <-
rbind(breakpoints, get_breakpoints(df_one_geno, resp))
} else {
breakpoints <- get_breakpoints(df_one_geno, resp)
}
}
breakpoints <- as.data.frame(breakpoints)
colnames(breakpoints) <- c("Initial", "Est.", "St.Err") # Needed in case a 3x3 matrix of zeros with no colnames is made!
breakpoints$geno <- c(11, 2, 5)
breakpoints$measure <- c(rep(resp, 3))
breakpoints$subset <- c(rep(subset, 3))
if (resp != response[1]) {
breakpoints_df <- rbind(breakpoints_df, breakpoints)
} else {
breakpoints_df <- breakpoints
}
}
rownames(breakpoints_df) <- seq(1, nrow(breakpoints_df))
return(breakpoints_df)
}
run_breakpoint_analysis <-
function() {
df <-
rbind(
cycle_genotypes(
infile = "data/recovery_plants_clean.csv",
subset = "Recovery",
response =  c(
"urgr",
"uH",
"max_rgr",
"max_H",
"B_total",
"B_below",
"B_above",
"A_B"
)
),
cycle_genotypes(
infile = "data/biomass_plants_clean.csv",
subset = "Cumulative",
response =  c(
"ssa",
"srl",
"SLA",
"Rv",
"Rt",
"Rsa_la",
"Rsa",
"Rl",
"Rd",
"LA",
"DMCv",
"DMCr",
"Bv",
"Br",
"A_B"
)
),
cycle_genotypes(
infile = "data/phys_plants_clean.csv",
subset = "Instantaneous",
response =  c(
"uWUEi",
"ugs",
"ufv",
"uAnet",
"max_WUEi",
"max_gs",
"max_fv",
"max_Anet"
)
),
cycle_genotypes(
infile = "data/all_plants_clean.csv",
subset = "Growth",
response =  c(
"urgr",
"uH",
"max_rgr",
"max_H")
)
)
write.csv(df, file = "output/breakpoint_analysis.csv")
}
df <-
rbind(
cycle_genotypes(
infile = "data/recovery_plants_clean.csv",
subset = "Recovery",
response =  c(
"urgr",
"uH",
"max_rgr",
"max_H",
"B_total",
"B_below",
"B_above",
"A_B"
)
),
cycle_genotypes(
infile = "data/biomass_plants_clean.csv",
subset = "Cumulative",
response =  c(
"ssa",
"srl",
"SLA",
"Rv",
"Rt",
"Rsa_la",
"Rsa",
"Rl",
"Rd",
"LA",
"DMCv",
"DMCr",
"Bv",
"Br",
"A_B"
)
),
cycle_genotypes(
infile = "data/phys_plants_clean.csv",
subset = "Instantaneous",
response =  c(
"uWUEi",
"ugs",
"ufv",
"uAnet",
"max_WUEi",
"max_gs",
"max_fv",
"max_Anet"
)
),
cycle_genotypes(
infile = "data/all_plants_clean.csv",
subset = "Growth",
response =  c(
"urgr",
"uH",
"max_rgr",
"max_H")
)
)
df
write.csv(df, file = "output/breakpoint_analysis.csv")
